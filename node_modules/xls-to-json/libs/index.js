var fs = require('fs');
var xlsjs = require('xlsjs');
var cvcsv = require('csv');
var path = require('path');

exports = module.exports = XLS_json;

// exports.XLS_json = XLS_json;

function XLS_json (config, callback) {
  if(!config.input) {
    console.error("You miss a input file");
    process.exit(1);
  }

  var cv = new CV(config, callback);
  
}

function CV(config, callback) { 
  var wb = this.load_xls(config.input)
  var ws = this.ws(wb, config.sheet);
  var csv = this.csv(ws)
  this.cv2json(csv, config, callback)
}

CV.prototype.load_xls = function(input) {
  return xlsjs.readFile(input);
}

CV.prototype.ws = function(wb, target_sheet) {
  ws = wb.Sheets[target_sheet ? target_sheet : wb.SheetNames[0]];
  return ws;
}

CV.prototype.csv = function(ws) {
  return csv_file = xlsjs.utils.make_csv(ws)
}

CV.prototype.cvjson = function(csv, output, callback) {
  var record = []
  var header = []

  cvcsv()
    .from.string(csv)
    .transform( function(row){
      row.unshift(row.pop());
      return row;
    })
    .on('record', function(row, index){
      
      if(index === 0) {
        header = row;
      }else{
        var obj = {};
        header.forEach(function(column, index) {
          obj[column.trim()] = row[index].trim();
        })
        record.push(obj);
      }
    })
    .on('end', function(count){
      // when writing to a file, use the 'close' event
      // the 'end' event may fire before the file has been written
      if(output !== null) {
      	var stream = fs.createWriteStream(output, { flags : 'w' });
      	stream.write(JSON.stringify(record));
      	callback(null, record);
      } else {
      	callback(null, record);
      }
      
    })
    .on('error', function(error){
      console.log(error.message);
    });
}


CV.prototype.cv2json = function(csv, config, callback) {

    var output=config.output;
    var dataName=config.dataName;
    var soutput=config.soutput;

    var record = [];
    var frontRecord = [];  //前端数据
    var names = null;
    var fields = null;

    dataName=dataName || "data";

  cvcsv()
      .from.string(csv)
      .transform( function(row){
        //row.unshift(row.pop());
        return row;
      })
      .on('record', function(row, index){

          if(index == 0){
              fields=[];
              for(var i=0;i<row.length;i++) {
                  fields[i] = row[i];
              }
          }

          /*
          if(row[0]==="NAME")
          {
              names =[];
              for(var i=0;i<row.length;i++) {
                  names[i] = row[i];
              }
          }else if(row[0]==="FIELDS"){

              fields=[];
              for(var i=0;i<row.length;i++) {
                  fields[i] = row[i];
              }
          }

          if(row[0]==="NAME" || row[0]==="FIELDS"){
              if (!names || !fields) return;

              var resultRow=[];
              var fieldRow=[];
              var fieldIndex=0;
              for(var i=1;i<names.length;i++)
              {
                  fields[i]=fields[i].trim();
                  if(!!fields[i] && fields[i].length>0){

                      fieldRow[fieldIndex]=fields[i];
                      resultRow[fieldIndex]=names[i].trim();

                      fieldIndex++;
                  }
              }
              record.push(resultRow);
              record.push(fieldRow);
          }
          */

          // if(row[0]==="VALUE"){

              var resultRow=[];
              var fieldIndex=0;
              for(var i=0;i<row.length;i++)
              {
                  if(!!fields[i] && fields[i].length>0 && config.fieldFilter(config.sheet,fields[i])){
                      var data=row[i].trim();
                      var toNumber=Number(data);
                      if(isNaN(toNumber))
                      {
                          resultRow[fieldIndex]=data;
                      }
                      else
                      {
                          // if (data.charAt(0)==="[" || data.charAt(0)==="{") {
                          //   resultRow[fieldIndex]=JSON.parse(data);
                          // }else{
                            resultRow[fieldIndex]=toNumber;
                          // }
                      }
                      fieldIndex++;
                  }
              }

              if(config.rowFilter(config.sheet,fields,row,true)){
                  frontRecord.push(resultRow);
              }
              if(config.rowFilter(config.sheet,fields,row,false)) {
                  record.push(resultRow);
              }

          // }

      })
      .on('end', function(count){
        // when writing to a file, use the 'close' event
        // the 'end' event may fire before the file has been written

          // if (record[1].length===1) {
          //   var newRecord=[];
          //   for (var i = 0; i < record.length; i++) {
          //       var r=record[i];
          //       newRecord.push(r[0]);
          //   };
          //   record=newRecord;
          // }


          var recordStr=JSON.stringify(record);
          if(soutput !== null) {
              var stream = fs.createWriteStream(soutput, { flags : 'w' });
              stream.write(recordStr);
          }

          //var resultStr="config."+dataName+"="+recordStr;
          var resultStr=JSON.stringify(frontRecord);;

          if(output !== null) {
              var stream = fs.createWriteStream(output, { flags : 'w' });
              stream.write(resultStr);
              callback(null, record,dataName);
          } else {
              callback(null, record,dataName);
          }
      })
      .on('error', function(error){
            console.log(error.message);
      });
}